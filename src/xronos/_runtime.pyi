# SPDX-FileCopyrightText: Copyright (c) 2025 Xronos Inc.
# SPDX-License-Identifier: BSD-3-Clause

import datetime
from typing import Any, Callable, TypeAlias

class BaseEnvironment: ...
class MetricDataLoggerProvider: ...
class AttributeManager: ...
class TelemetryBackend: ...

AttributeValue: TypeAlias = str | bool | int | float

class Environment(BaseEnvironment):
    def __init__(
        self,
        workers: int,
        fast: bool,
        timeout: datetime.timedelta = ...,
    ) -> None: ...
    def _execute(self, source_infos: list[SourceInfo]) -> None: ...
    def _connect(self, from_: Port, to: Port) -> None: ...
    def _connect_delayed(
        self, from_: Port, to: Port, delay: datetime.timedelta
    ) -> None: ...
    def request_shutdown(self) -> None: ...
    @property
    def _top_level_reactors(self) -> set[Reactor]: ...
    @property
    def _metric_data_logger_provider(self) -> MetricDataLoggerProvider: ...
    @property
    def _attribute_manager(self) -> AttributeManager: ...
    def _add_attribute(
        self, element: ReactorElement, key: str, value: AttributeValue
    ) -> bool: ...
    def _add_attributes(
        self, element: ReactorElement, attributes: dict[str, AttributeValue]
    ) -> bool: ...
    def _set_telemetry_backend(self, backend: TelemetryBackend) -> None: ...

class ValidationError(Exception):
    def __init__(self, message: str) -> None: ...

class SourceInfo:
    def __init__(
        # number of arguments is to add more classes, which would in turn need CPP
        # bindings. The complexity is not justified.
        self,
        class_name: str | None,
        function: str,
        file: str,
        fqn: list[str],
        uid: int,
        lineno: int,
        end_lineno: int,
        col_offset: int,
        end_col_offset: int,
    ) -> None:
        self.class_name: str | None
        self.function: str
        self.file: str
        self.fqn: list[str]
        self.uid: int
        self.lineno: int
        self.end_lineno: int
        self.col_offset: int
        self.end_col_offset: int

class ReactorElement:
    @property
    def _name(self) -> str: ...
    @property
    def _fqn(self) -> str: ...
    @property
    def _uid(self) -> int: ...
    @property
    def _environment(self) -> Environment: ...

class Reactor(ReactorElement):
    def __init__(self, name: str, container: Environment | Reactor) -> None: ...
    def _assemble(self) -> None: ...
    @staticmethod
    def _get_physical_time() -> datetime.datetime: ...
    def _get_logical_time(self) -> datetime.datetime: ...
    def _get_elapsed_logical_time(self) -> datetime.timedelta: ...
    @property
    def _reactor_instances(self) -> set[Reactor]: ...
    def _set_attributes(self, attributes: dict[str, int | float | str]) -> None: ...
    def _add_attribute(self, key: str, value: int | float | str) -> None: ...

class EventSource(ReactorElement):
    @property
    def _is_present(self) -> bool: ...

class SchedulableEventSource(EventSource):
    def _get(self) -> Any: ...
    def _schedule(self, value: Any, delay: datetime.timedelta) -> None: ...

class InternalEvent(SchedulableEventSource):
    def __init__(self, name: str, container: Reactor) -> None: ...

class PhysicalEvent(SchedulableEventSource):
    def __init__(self, name: str, container: Reactor) -> None: ...

class Timer(EventSource):
    def __init__(
        self,
        name: str,
        container: Reactor,
        period: datetime.timedelta,
        offset: datetime.timedelta,
    ) -> None: ...
    @property
    def _period(self) -> datetime.timedelta: ...
    @_period.setter
    def _period(self, value: datetime.timedelta) -> None: ...
    @property
    def _offset(self) -> datetime.timedelta: ...
    @_offset.setter
    def _offset(self, value: datetime.timedelta) -> None: ...

class Startup(Timer):
    def __init__(self, name: str, container: Reactor) -> None: ...

class Shutdown(Timer):
    def __init__(self, name: str, container: Reactor) -> None: ...

class Reaction(ReactorElement):
    def __init__(
        self,
        name: str,
        priority: int,
        container: Environment | Reactor,
        handler: Callable[[], None],
    ) -> None: ...
    def _declare_event_source_trigger(self, trigger: EventSource) -> None: ...
    def _declare_port_trigger(self, trigger: BasePort) -> None: ...
    def _declare_event_source_effect(self, effect: EventSource) -> None: ...
    def _declare_port_effect(self, effect: BasePort) -> None: ...
    def _declare_port_source(self, effect: BasePort) -> None: ...

class BasePort(ReactorElement):
    pass

class Port(BasePort):
    @property
    def _is_present(self) -> bool: ...
    def _set(self, value: Any) -> None: ...
    def _get(self) -> Any: ...

class Input(Port):
    def __init__(self, name: str, container: Reactor) -> None: ...

class Output(Port):
    def __init__(self, name: str, container: Reactor) -> None: ...

class Metric(ReactorElement):
    def __init__(
        self,
        name: str,
        container: Reactor,
        metric_data_logger_provider: MetricDataLoggerProvider,
        description: str,
        unit: str,
    ) -> None: ...
    def _record(self, value: int | float) -> None: ...
    @property
    def _description(self) -> str: ...
    @property
    def _unit(self) -> str: ...
    def _get_attributes(self) -> dict[str, int | float | str]: ...

class ContextHandle:
    pass

def enable_tracing(endpoint: str, application_name: str) -> None: ...
def shutdown_tracing() -> None: ...
def record_event(
    event_name: str,
    timestamp: datetime.datetime,
    tags: dict[str, str | float | int],
    low_cardinality_attributes: list[str],
) -> None: ...
